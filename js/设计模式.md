# 设计模式
## 设计模式的概念
		设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。其实就是前人总结的，针对特定类型问题的设计方案
	
	总体来说设计模式分为三大类：
	创建型模式,共五种：
		工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
	结构型模式,共七种：
		适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
	行为型模式,共十一种：
		策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 设计模式的六大原则
	总体原则：开闭原则（Open Close Principle）
		开闭原则就是说对扩展开放，对修改关闭。在程序需要进行扩展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。
	
	1、单一职责原则
		不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。
	2、里氏代换原则（Liskov Substitution Principle）
		里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类（父类）可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
	3、依赖倒转原则（Dependence Inversion Principle）
		这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
	4、接口隔离原则（Interface Segregation Principle）
		这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
	5、迪米特法则（最少知道原则）（Demeter Principle）
		为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
	6、合成复用原则（Composite Reuse Principle）
		原则是尽量使用合成/聚合的方式，而不是使用继承。

## 单例模式	
	创建模式_单例模式
	某个类只允许创建一个实例，这就是单例模式。优点如下：
		1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销
		2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。
		3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如：中国国家主席只有一个，飞机大战的地图对象只有一个），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。
	
	应用：
		遮罩层有可能是某个项目中经常要频繁创建的实例，如果不停地创建和删除，还是很浪费资源。应该，在首次使用时创建，以后只是使用首次创建的实例
		放大镜有可能在某个项目中经常要频繁地创建的实例，也是很浪费资源。

### 单例模式_示列代码

```html
var Singleton = (function(){
	function Map(width,height){
		this.width = width;
		this.height = height;
	}
	var instance;
	return {
		getInstance:function(width,height){
			if(instance==undefined){
				instance = new Map(width,height);
			}else{
				instance.width = width;
				instance.height = height;
			}
			return instance;
		}
	}
})();
var t1 = Singleton.getInstance(100,200);
var t2 = Singleton.getInstance(250,350);

function Map(width,height){
	if(typeof Map.instance =='object'){
		Map.instance.width = width;
		Map.instance.height = height;
		return Map.instance;
	}
	this.width = width;
	this.height = height;
	Map.instance = this;
}
var t1 = new Map(100,200);
var t2 = new Map(250,350);
```

## 代理模式	
	结构模式_代理模式
	代理模式的定义是把对一个对象的访问, 交给另一个代理对象来操作。
	
	应用场景：
	如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
		1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
		2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。使用代理模式，可以将功能划分的更加清晰，有助于后期维护！

### 代理模式_示列代码

```html
//人：需要有代理可以看门
function Person(name,delegate){
	this.name = name;//人的姓名
	this.delegate = delegate;//人的代理
}
//人需要看门
Person.prototype.lookDoor = function(){
	this.delegate.lookDoor();//让人的代理开门
}
//狗：可以作为人的代理看门
function Dog(name){
	this.name= name;
}
Dog.prototype.lookDoor = function(){
	alert(this.name+"在聚精会神地盯着大门口");
}
var p = new Person("老王",new Dog("小黑"));
p.lookDoor();
//老虎：可以作为人的代理看门
function Tiger(name){
	this.name= name;
}
Tiger.prototype.lookDoor = function(){
	alert(this.name+"在虎视眈眈地盯着大门口");
}
p.delegate = new Tiger("虎哥");
p.lookDoor();

```

## 适配器模式	
	结构模式_适配器模式
		适配器模式，一般是为要使用的接口，不能完全符合本应用或本系统使用，而需引入的中间适配层类或对象的情况；
	如：
		手机充电器，Android手机的充电线没法给iPhone手机充电，因为，口不对，插不进去，如果有一个能够Android手机的充电线的头转换成能插在iPhone手机上的设备，这个就是适配器（转接口，转接头），恰好已经有了。
	再如：
		你需要6v的电压，但是，目前墙上有一个提供220v电压的插孔，怎么办，有个设备能把220v转成6v，交流转成直流，这个设备就是适配器。
	
	应用场景：
		由于旧的系统，或第三方应用提供的接口（更多特指函数的参数），与我们定义的接口不匹配，就无法使用这样旧的，或第三方的接口，这时我们就使用适配类继承待适匹配的类，并让适配类实现接口的方式来引入旧的系统或第三方应用的接口；
### 适配器模式_示列代码 

```html
//旧类：
function OldClass(){
}
//旧类的函数func1有一个参数。
OldClass.prototype.func1 = function(arg1){
	console.log("我是旧类OldClass的func1函数，我只有一个参数：arg1");
}

//适配器类；AdapterClass
//因为使用函数OldClass.func1功能的地方，有两个参数。所以需要有中间类来进行转换，
//即把本该想调动函数OldClass.func1的地方改成调用AdapterClass类的函数
function AdapterClass(oldClass){
	this.oldClass = oldClass;
}
//func2就是转换函数。
AdapterClass.prototype.func2=function(arg1,arg2){
	arg2 = "hello";
	this.oldClass.func1(arg1);//最终还是调用OldClass的func1函数。
}
//使用类的代码：
//定义一个适配器，由适配器把旧类的对象包装起来。
var a = new AdapterClass(new OldClass());
//调用适配器的func2函数，最终还是得调用旧类的func2函数。
a.func2();//

使用类的代码：
//定义一个适配器，由适配器把旧类的对象包装起来。
var a = new AdapterClass(new OldClass());
//调用适配器的func2函数，最终还是得调用旧类的func2函数。
a.func2();//
```

## 工厂模式
	创建模式_工厂模式
		工厂模式，就是用工厂的思路，创建对象。工厂是造产品的。现在用工厂来造对象。即一个工厂可以制造很多种类型的对象，这些对象一般具有共同的父类，即相似的类。
	以下几种情景下工厂模式特别有用：
		对象的构建十分复杂
		需要依赖具体环境创建不同实例
		处理大量具有相同属性的小对象
### 工厂模式_示列代码

```html
var FamilyE={};
//空调
FamilyE.KongTiao = function(){
	console.log("造了一台空调");
}
//洗衣机
FamilyE.Wash=function(){
	console.log("造了一台洗衣机");
}
//冰箱
FamilyE.Ice=function(){
	console.log("造了一台冰箱");
}
//用家电工厂对象分别创建对象：空调，洗衣机，冰箱
new FamilyE["KongTiao"]();
new FamilyE["Wash"]();
new FamilyE["Ice"]();
```

## 组合模式
	结构_组合模式
		组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。
		组合模式是一种专门为创建Web上的动态用户界面而量身制定的模式。使用这种模式可以用一条命令在多个对象上激发复杂的或递归的行为。这可以简化粘合性代码，使其更容易维护，而那些复杂行为则被委托给各个对象
	优点 ：
		1.你可以用同样的方法处理对象的集合与其中的特定子对象。
		2.它可以用来把一批子对象组织成树形结构，并且使整棵树都可以被遍历。	
​	
​	常见的场景:
		DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。所以说组合模式的关键是要有一个抽象类，它既可以表示子元素，又可以表示父元素。
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	