###原型链
	1.每一个类或者函数都有一个prototype属性，并且这个属性是一个对象数据类型的值
	2.prototype上有一个contructor属性指向函数本身
	3.所有对象（普通对象，实例，prototype...）都一个__proto__属性指向当前实例所属类的原型
	
	当前实例调用方法的时候：先找私有的，私有的没有在找公有的
	__proto__：指向原型

### 细节知识点
	便利  for VS for in
	for循环一般我们用来遍历数组和类数组
	
	for in一般用来循环遍历对象 不建议用来循环遍历数组
	1.会把下标变为字符串
	2.for in循环会把私有属性或方法和公有属性或方法

### 判断是不是私有属性	
	for(var key in a1){
	//判断是不是私有属性hasOwnProperty
	// if (a1.hasOwnProperty(key)){
		//console.log(key);
	// }
	
	//propertyIsEnumerable:是否可枚举  默认共有属性不可枚举，只能枚举私有属性
	if (a1.propertyIsEnumerable(key)){
		console.log(key);
	    }
	}

###继承方式
	call apply bind
	他们三个有一个共同的作用就是改变this指向
	怎么看this：当前这个调用这个方法或属性.前面是谁就是谁
	
	call的作用：让当前方法执行并且将this变为这个参数(传谁就是谁)
	call和apply
	共同点：都是先让当前方法执行，并且让当前这个方法中的this变为第一个参数
	
	call和apply是可以传递多个参数的
	call：第一个参数改变this指向的  以后参数都是传递的实参
	apply:第一个参数改变this指向的   后边可以传递一个数组
	
	//call apply一样都是用来改变this指向的只不过apply传递的参数是单个的，而apply是数组
	//bind:也是用来改变this指向
	function A() {
	    this.age = 100;
	}
	
	A.prototype.getY = function (x,y) {
	    console.log(this);
	    console.log(this.age,x,y);
	}
	
	var a = new A();
	
	var obj = {name:"HAHA"};
	//bind也是用来改变this指向的只不过不是立即改变，什么时候调用什么时候才改变
	var temBind = a.getY.bind(obj,100,200);
	//这里的返回值就是要执行的那个函数
	console.log(temBind);
	//调用去改变this指向并且出传递参数
	temBind();

### 将类数组转为数组
	function sortArr() {
	    //将类数组转为数组
	   var arr =  Array.prototype.slice.call(arguments);
	}

### 继承
	1.原型继承   本身自己私有的公有的不变  父类公有的加私有的都会成为子类公有的
	(1)让当前这个类的原型指向父类的实例
	(2)要重新定义constructor指向
	
	call继承只能继承父类的私有属性
	
	//原型继承：将父类公有+私有都作为子类公有
	//call继承：将父类私有作为子类私有
	
	//混合继承
	//或把父类私有作为子类私有的，并且把父类公有+私有的作为子类公有的
### 将类数组转为数组 
	function = sortArr(){
		Array.prototype.slice.call(arguments);
	}
	sortArr(100,12,130,15,45,22);
	
	//将li转为数组
	var lis = ul.getElementsByTagName("li");
	console.log(Array.prototype.slice.call(lis));